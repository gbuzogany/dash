// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HONDA_DASH_H_
#define FLATBUFFERS_GENERATED_HONDA_DASH_H_

#include "flatbuffers/flatbuffers.h"

namespace dash {

struct ECUMessage;

struct ECUMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BATTVOLTAGE = 4,
    VT_COOLANTTEMP = 6,
    VT_AIRINTAKETEMP = 8,
    VT_MANIFOLDPRESSURE = 10,
    VT_SPEED = 12,
    VT_TPS = 14,
    VT_RPM = 16,
    VT_NEUTRAL = 18,
    VT_ENGINERUNNING = 20
  };
  float battVoltage() const {
    return GetField<float>(VT_BATTVOLTAGE, 0.0f);
  }
  float coolantTemp() const {
    return GetField<float>(VT_COOLANTTEMP, 0.0f);
  }
  float airIntakeTemp() const {
    return GetField<float>(VT_AIRINTAKETEMP, 0.0f);
  }
  float manifoldPressure() const {
    return GetField<float>(VT_MANIFOLDPRESSURE, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  float tps() const {
    return GetField<float>(VT_TPS, 0.0f);
  }
  int32_t rpm() const {
    return GetField<int32_t>(VT_RPM, 0);
  }
  int32_t neutral() const {
    return GetField<int32_t>(VT_NEUTRAL, 0);
  }
  bool engineRunning() const {
    return GetField<uint8_t>(VT_ENGINERUNNING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BATTVOLTAGE) &&
           VerifyField<float>(verifier, VT_COOLANTTEMP) &&
           VerifyField<float>(verifier, VT_AIRINTAKETEMP) &&
           VerifyField<float>(verifier, VT_MANIFOLDPRESSURE) &&
           VerifyField<float>(verifier, VT_SPEED) &&
           VerifyField<float>(verifier, VT_TPS) &&
           VerifyField<int32_t>(verifier, VT_RPM) &&
           VerifyField<int32_t>(verifier, VT_NEUTRAL) &&
           VerifyField<uint8_t>(verifier, VT_ENGINERUNNING) &&
           verifier.EndTable();
  }
};

struct ECUMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_battVoltage(float battVoltage) {
    fbb_.AddElement<float>(ECUMessage::VT_BATTVOLTAGE, battVoltage, 0.0f);
  }
  void add_coolantTemp(float coolantTemp) {
    fbb_.AddElement<float>(ECUMessage::VT_COOLANTTEMP, coolantTemp, 0.0f);
  }
  void add_airIntakeTemp(float airIntakeTemp) {
    fbb_.AddElement<float>(ECUMessage::VT_AIRINTAKETEMP, airIntakeTemp, 0.0f);
  }
  void add_manifoldPressure(float manifoldPressure) {
    fbb_.AddElement<float>(ECUMessage::VT_MANIFOLDPRESSURE, manifoldPressure, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(ECUMessage::VT_SPEED, speed, 0.0f);
  }
  void add_tps(float tps) {
    fbb_.AddElement<float>(ECUMessage::VT_TPS, tps, 0.0f);
  }
  void add_rpm(int32_t rpm) {
    fbb_.AddElement<int32_t>(ECUMessage::VT_RPM, rpm, 0);
  }
  void add_neutral(int32_t neutral) {
    fbb_.AddElement<int32_t>(ECUMessage::VT_NEUTRAL, neutral, 0);
  }
  void add_engineRunning(bool engineRunning) {
    fbb_.AddElement<uint8_t>(ECUMessage::VT_ENGINERUNNING, static_cast<uint8_t>(engineRunning), 0);
  }
  explicit ECUMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ECUMessageBuilder &operator=(const ECUMessageBuilder &);
  flatbuffers::Offset<ECUMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ECUMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ECUMessage> CreateECUMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    float battVoltage = 0.0f,
    float coolantTemp = 0.0f,
    float airIntakeTemp = 0.0f,
    float manifoldPressure = 0.0f,
    float speed = 0.0f,
    float tps = 0.0f,
    int32_t rpm = 0,
    int32_t neutral = 0,
    bool engineRunning = false) {
  ECUMessageBuilder builder_(_fbb);
  builder_.add_neutral(neutral);
  builder_.add_rpm(rpm);
  builder_.add_tps(tps);
  builder_.add_speed(speed);
  builder_.add_manifoldPressure(manifoldPressure);
  builder_.add_airIntakeTemp(airIntakeTemp);
  builder_.add_coolantTemp(coolantTemp);
  builder_.add_battVoltage(battVoltage);
  builder_.add_engineRunning(engineRunning);
  return builder_.Finish();
}

inline const dash::ECUMessage *GetECUMessage(const void *buf) {
  return flatbuffers::GetRoot<dash::ECUMessage>(buf);
}

inline const dash::ECUMessage *GetSizePrefixedECUMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<dash::ECUMessage>(buf);
}

inline bool VerifyECUMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<dash::ECUMessage>(nullptr);
}

inline bool VerifySizePrefixedECUMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<dash::ECUMessage>(nullptr);
}

inline void FinishECUMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<dash::ECUMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedECUMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<dash::ECUMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace dash

#endif  // FLATBUFFERS_GENERATED_HONDA_DASH_H_
